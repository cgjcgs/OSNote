### 进程的分身术 --- 线程

进程分解为线程（一个进程内同时干多件事件) 有效的利用多处理器和多核计算机
**进程是操作系统的概念 而CPU的执行是线程**

> 每个线程本质上是一样的 拥有相同的程序文本
> 
> 每个线程上下文又是不一样的 比如: 线程名称 等数据

不同的线程可以使用不通的处理器运算。如果没有多线程 增加一个处理器并不能提高一个进程的执行速度。

**一个典型的使用场景**：

word 多个线程 。一个负责显示 一个负责输入 一个定时存盘 
否则 显示 输入 存盘不能同时进行

### 线程管理

> 线程控制表 和 线程信息：

|    独享资源 (存储于线程控制表)     | 线程共享资源（存储于进程控制表） |
| :-----------------------------: | :--------------------------: |
| 程序计数器						 |  地址空间					 	|
| 寄存器      					 |  全局变量 					|
| 栈								|	打开的文件					|
| 状态字							|	子进程						 |
|								|  闹铃							|
|								|  信号及信号服务程序				|
|								|  记账程序						|


**线程需要协作 关于资源共享还是不共享 原则是 共享的资源越多越好**

----

### 线程的实现方式

> **线程是CPU调度的基本单位**

#### 内核态线程实现(CPU调度由操作系统来实现的 可以让操作系统来管理线程)

线程控制表放入系统内核空间 (系统通知保有进程和线程的控制表)

根据 进程和线程控制表的信息 系统可以对线程进行管理：`线程调度`、`线程资源分配`、`各种安全措施` 等

> 优点

- 用户编程无需管理线程调度 (无需担心什么时候 执行 挂起等)
- 如果一个线程执行阻塞操作 系统从容调度另一个线程执行 **系统可以监控所有线程** 

> 缺点

- 效率较低 每次线程切换都需要陷入到内核需要花费时间
- 维护线程表占用内核稀缺的内存资源(操作系统的内核空间装置结束后已经固定。线程的数量通常远大于进程数量。内核空间随着线程增加迅速耗尽)
- 内核态需要修改操作系统

如果进程需要创建线程是内核空间不够肿么办？

1. 杀死别的进程 造成其他服务异常
2. 创建失败   有可能意味着整个进程无法推进 违反进程模型的 **时序推进要求**
3. 让它等待 系统线程 关键人物无法启用；用户线程 用户强烈不满

**Warning：** 由此可见 这不是个好注意


#### 用户态线程实现(进程自己管理)

**线程控制表在用户态空间**

自己做线程切换、线程调度、管理线程信息。操作系统无需知道线程的存在

线程调度： 用户自己写一个执行系统 座位调度器。除了正常的执行任务的线程外 还有一个专门负责调度的线程。

大家都在用户态下 系统管不着（没人做主） 要想获得CPU只能大家自愿合作 执行一段时间主动释放给别人。
`操作系统可以通过周期性的时钟中断把控制权夺过来 分配给别的线程` 


> 优点

- 灵活性 系统管不着、任何系统都能应用
- 线程切换快 不用陷入内核态
- 不用修改操作系统

> 缺点

- 容易出问题 何时让出CPU给别的线程 时机对线程的效率可靠性影响很大
- **根本无法到达线程的目的 ： 进程级多道编程** 从进程一次只能出去一条线程 在系统看来还是一个进程内只有一个线程 **一个线程受阻 整个进程无法推进 系统会把CPU交给另一个进程**




-----