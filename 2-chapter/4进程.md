
**进程是操作系统的概念 而CPU的执行是线程**


###  进程

*为了提高CPU使用率 将多个程序同时加载到计算机并发执行 同时存在于内存中的程序为进程*

### 进程模型


-  物理视角(进程切换)

*每个进程占用一块内存；同一时刻只有一条指令执行 执行顺序由物理程序计数器指定 所有进程共用一个计数器*

-  逻辑视角（多道并发）

*进程通过 <挂起和恢复> 轮流执行. 就必须要记住目前执行的位置 恢复时接着执行。因此每个进程有自己的<计数器> 记录下一条指令的位置*

-  时序视角（持续推进）

*进程只能根据记录的下条指令往前执行*


### 多道编程的效率

*多道编程并发可提高CPU的利用率*

如：一个程序的I/O占80% CPU计算占20% 

多进程时的CPU利用率为 1-0.8ⁿ  （n为进程数）

当进程数量增加到某个临界点时 由于进程切换运行等系统消耗会导致多道编程的好处下降 逐步消失 （上面例子超过6个 **这点时间不够给你切换的** ）


### 进程的产生和消失

> 产生

- 系统初始化 (如 linux的init)
- 执行进程创建子进程 (fork 或 createprocess)
- 用户请求创立新进程 (打开软件)

> 消失

- 进程运行完成后退出
- 进程错误后自行退出
- 进程被其他进程强行杀死
- 进程因一场而强行终结(被操作系统)

**Note:** linux通过init进程创建子进程 N层进程结构形成了 **进程树**。 window 所有进程地位平等 

### 进程的而状态

- 执行态(我正用着呢)
- 阻塞态(你在忙别的 CPU给你你也用不上)
- 就绪态(就等CPU了)

**Note：** 实际上操作系统并不一定只是这三种状态 win有7个

### 进程创立

@todo 不够详细 

1. 分配进程可控制卡
2. 初始化机器寄存器
3. 初始化页表
4. 讲程序代码从磁盘读进内存
5. 讲处理器状态设置为 **用户态**
6. 跳转到程序的起始地址(设置程序计数器)


### 进程管理

#### 进程表 PCB （process control block）
不同的操作系统进程资料不尽相同 一般来说：

- 寄存器、
- 程序计数器、
- 状态字、
- 栈指针、
- 优先级、
- 进程ID、
- 信号、
- 创立时间、
- 所耗CPU时间、
- 当前持有的各种句柄

以上资料数据结构主要是 线性表 链表 结构 也可能树和图

如 solaris：

- 进程基础信息指针(进程ID、创建用户、创立时间等)
- 进程家族树指针（子进程、父进程、孙子进程、祖父进程）
- 进程资源信息指针(寄存器、栈指针、当前持有的句柄等)
- 信号支持
- 进程状态信息指针(程序寄存器 状态字 优先级等)
- 时间统计信息(所占CPU时间 子进程所占CPU时间等)
- 其他信息指针 ..... 

**进程表在操作系统的内核空间里** 

**进程管理中 【 公平、效率 】 不同的倾斜引不同的进程管理模式**

#### 进程的缺陷

- 在同一个时间点 不能做多件事
- 进程执行中如果阻塞 技术其他工作不依赖阻塞的操作 也无法推进
**由此发明了线程**






  

