###  进程

*为了提高CPU使用路 将多个程序同时加载到计算机并发执行 同时存在于内存中的程序为进程*

### 进程模型


-  物理视角(进程切换)

*每个进程占用一块内存；同一时刻只有一条指令执行 执行顺序由物理程序计数器指定 所有进程共用一个计数器*

-  逻辑视角（多道并发）

*进程通过 <挂起和恢复> 轮流执行. 就必须要记住目前执行的位置 恢复时接着执行。因此每个进程有自己的<计数器> 记录下一条指令的位置*

-  时序视角（持续推进）

*进程只能根据记录的下条指令往前执行*


### 多道编程的效率

*多道编程并发可提高CPU的利用率*

如：一个程序的I/O占80% CPU计算占20% 

多进程时的CPU利用率为 1-0.8ⁿ  （n为进程数）

当进程数量增加到某个临界点时 由于进程切换运行等系统消耗会导致多道编程的好处下降 逐步消失 （上面例子超过6个 **这点时间不够给你切换的** ）


### 进程的产生和消失

> 产生

- 系统初始化 (如 linux的init)
- 执行进程创建子进程 (fork 或 createprocess)
- 用户请求创立新进程 (打开软件)

> 消失

- 进程运行完成后退出
- 进程错误后自行退出
- 进程被其他进程强行杀死
- 进程因一场而强行终结(被操作系统)

**Note:** linux通过init进程创建子进程 N层进程结构形成了 **进程树**。 window 所有进程地位平等 

### 进程的而状态

- 执行态(我正用着呢)
- 阻塞态(你在忙别的 CPU给你你也用不上)
- 就绪态(就等CPU了)

**Note：** 实际上操作系统并不一定只是这三种状态 win有7个

### 进程创立

@todo 不够详细 

1. 分配进程可控制卡
2. 初始化机器寄存器
3. 初始化页表
4. 讲程序代码从磁盘读进内存
5. 讲处理器状态设置为 **用户态**
6. 跳转到程序的起始地址(设置程序计数器)





  

